namespace PCLMock.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using System.Threading.Tasks;
    using Logging;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Editing;
    using Microsoft.CodeAnalysis.MSBuild;

    public static class Generator
    {
        private static readonly Type logSource = typeof(Generator);

        private const string headerComment =
@"-----------------------------------------------------------------------
<autogenerated>
   This code was generated from a template.

   Changes to this file may cause incorrect behaviour and will be lost
   if the code is regenerated.
</autogenerated>
------------------------------------------------------------------------";

        public async static Task<IImmutableList<SyntaxNode>> GenerateMocksAsync(
            ILogSink logSink,
            Language language,
            string solutionPath,
            Func<INamedTypeSymbol, bool> interfacePredicate,
            Func<INamedTypeSymbol, string> mockNamespaceSelector,
            Func<INamedTypeSymbol, string> mockNameSelector,
            IImmutableList<IPlugin> plugins)
        {
            var workspace = MSBuildWorkspace.Create();
            var solution = await workspace.OpenSolutionAsync(solutionPath);

            return await GenerateMocksAsync(
                logSink,
                language,
                solution,
                interfacePredicate,
                mockNamespaceSelector,
                mockNameSelector,
                plugins);
        }

        public async static Task<IImmutableList<SyntaxNode>> GenerateMocksAsync(
            ILogSink logSink,
            Language language,
            Solution solution,
            Func<INamedTypeSymbol, bool> interfacePredicate,
            Func<INamedTypeSymbol, string> mockNamespaceSelector,
            Func<INamedTypeSymbol, string> mockNameSelector,
            IImmutableList<IPlugin> plugins)
        {
            var syntaxGenerator = SyntaxGenerator.GetGenerator(solution.Workspace, language.ToSyntaxGeneratorLanguageName());
            var compilations = await Task.WhenAll(
                solution
                    .Projects
                    .Select(async project =>
                        {
                            var compilation = await project.GetCompilationAsync();
                            // make sure the compilation has a reference to PCLMock
                            compilation = compilation.AddReferences(MetadataReference.CreateFromFile(typeof(MockBase<>).Assembly.Location));

                            foreach (var plugin in plugins)
                            {
                                compilation = plugin.InitializeCompilation(compilation);
                            }

                            if (logSink.IsEnabled)
                            {
                                logSink.Debug(logSource, "Compilation generated for project '{0}' with references:", project.Name);

                                foreach (var reference in compilation.References)
                                {
                                    logSink.Debug(logSource, "- {0}", reference.Display);
                                }
                            }

                            return compilation;
                        }));

            return compilations
                .SelectMany(
                    compilation =>
                        GetSymbolsRecursive(compilation.SourceModule.GlobalNamespace)
                            .OfType<INamedTypeSymbol>()
                            .Where(typeSymbol => typeSymbol.TypeKind == TypeKind.Interface && !typeSymbol.IsImplicitlyDeclared)
                            .Where(typeSymbol => interfacePredicate == null || interfacePredicate(typeSymbol))
                            .Select(interfaceSymbol => new
                            {
                                InterfaceSymbol = interfaceSymbol,
                                Compilation = compilation
                            }))
                .Select(
                    x =>
                    {
                        var @namespace = mockNamespaceSelector(x.InterfaceSymbol);
                        var name = mockNameSelector(x.InterfaceSymbol);

                        if (logSink.IsEnabled)
                        {
                            logSink.Positive(
                                logSource,
                                "Generating mock for interface '{0}' with namespace '{1}', name '{2}'.",
                                x.InterfaceSymbol,
                                @namespace,
                                name);
                        }

                        var semanticModel = x.Compilation.GetSemanticModel(x.InterfaceSymbol.DeclaringSyntaxReferences.First().SyntaxTree);
                        var context = new Context(logSink, language, plugins, syntaxGenerator, semanticModel);
                        return GenerateMock(context, x.InterfaceSymbol, @namespace, name, plugins);
                    })
                .Select((syntaxNode, i) => i == 0 ? syntaxGenerator.WithLeadingComments(syntaxNode, headerComment, language) : syntaxNode)
                .ToImmutableList();
        }

        private static SyntaxNode GenerateMock(
            Context context,
            INamedTypeSymbol interfaceSymbol,
            string mockNamespace,
            string mockName,
            IImmutableList<IPlugin> plugins)
        {
            var namespaceSyntax = GetNamespaceDeclarationSyntax(context, mockNamespace);
            var classSyntax = GetClassDeclarationSyntax(context, mockName, interfaceSymbol);

            classSyntax = context
                .SyntaxGenerator
                .AddAttributes(classSyntax, GetClassAttributesSyntax(context));
            classSyntax = context
                .SyntaxGenerator
                .AddMembers(classSyntax, GetMemberDeclarations(context, mockName, interfaceSymbol, plugins));
            namespaceSyntax = context
                .SyntaxGenerator
                .AddMembers(namespaceSyntax, classSyntax);

            return context
                .SyntaxGenerator
                .CompilationUnit(namespaceSyntax)
                .NormalizeWhitespace();
        }

        private static SyntaxNode GetNamespaceDeclarationSyntax(
            Context context,
            string @namespace)
        {
            return context
                .SyntaxGenerator
                .NamespaceDeclaration(@namespace);
        }

        private static SyntaxNode GetClassDeclarationSyntax(
            Context context,
            string name,
            INamedTypeSymbol interfaceSymbol)
        {
            var interfaceType = context
                .SyntaxGenerator
                .TypeExpression(interfaceSymbol);
            var mockBaseType = context
                .SemanticModel
                .Compilation
                .GetTypeByMetadataName("PCLMock.MockBase`1");

            if (mockBaseType == null)
            {
                throw new InvalidOperationException("Failed to find type in PCLMock assembly. Are you sure this project has a reference to PCLMock?");
            }

            var baseType = context
                .SyntaxGenerator
                .TypeExpression(
                    mockBaseType
                        .Construct(interfaceSymbol));

            var accessibility = interfaceSymbol.DeclaredAccessibility == Accessibility.NotApplicable
                ? Accessibility.Public
                : interfaceSymbol.DeclaredAccessibility;

            var classDeclaration = context
                .SyntaxGenerator
                .ClassDeclaration(
                    name,
                    accessibility: accessibility,
                    modifiers: DeclarationModifiers.Partial,
                    typeParameters: interfaceSymbol.TypeParameters.Select(x => x.Name),
                    baseType: baseType,
                    interfaceTypes: new[] { interfaceType });

            // TODO: tidy this up once this issue is rectified: https://github.com/dotnet/roslyn/issues/1658
            foreach (var typeParameter in interfaceSymbol.TypeParameters)
            {
                if (typeParameter.HasConstructorConstraint ||
                    typeParameter.HasReferenceTypeConstraint ||
                    typeParameter.HasValueTypeConstraint ||
                    typeParameter.ConstraintTypes.Length > 0)
                {
                    var kinds = (typeParameter.HasConstructorConstraint ? SpecialTypeConstraintKind.Constructor : SpecialTypeConstraintKind.None) |
                                (typeParameter.HasReferenceTypeConstraint ? SpecialTypeConstraintKind.ReferenceType : SpecialTypeConstraintKind.None) |
                                (typeParameter.HasValueTypeConstraint ? SpecialTypeConstraintKind.ValueType : SpecialTypeConstraintKind.None);

                    classDeclaration = context
                        .SyntaxGenerator
                        .WithTypeConstraint(
                            classDeclaration,
                            typeParameter.Name,
                            kinds: kinds,
                            types: typeParameter.ConstraintTypes.Select(t => context.SyntaxGenerator.TypeExpression(t)));
                }
            }

            return classDeclaration;
        }

        private static IEnumerable<SyntaxNode> GetClassAttributesSyntax(
            Context context)
        {
            // GENERATED CODE:
            //
            //     [System.CodeDom.Compiler.GeneratedCode("PCLMock", "[version]")]
            //     [System.Runtime.CompilerServices.CompilerGenerated)]
            yield return context
                .SyntaxGenerator
                .Attribute(
                    "System.CodeDom.Compiler.GeneratedCode",
                    context
                        .SyntaxGenerator
                        .LiteralExpression("PCLMock"),
                    context
                        .SyntaxGenerator
                        .LiteralExpression(typeof(MockBase<>).Assembly.GetName().Version.ToString()));
            yield return context
                .SyntaxGenerator
                .Attribute(
                    "System.Runtime.CompilerServices.CompilerGenerated");
        }

        private static SyntaxNode GetConstructorDeclarationSyntax(
            Context context,
            string name)
        {
            // GENERATED CODE:
            //
            //     public Name(MockBehavior behavior = MockBehavior.Strict)
            //         : base(behavior)
            //     {
            //         ConfigureBehaviorGenerated();
            //         ConfigureBehavior();
            //
            //         if (behavior == MockBehavior.Loose)
            //         {
            //             ConfigureLooseBehaviorGenerated();
            //             ConfigureLooseBehavior();
            //         }
            //     }
            var mockBehaviorType = context
                .SyntaxGenerator
                .TypeExpression(
                    context
                        .SemanticModel
                        .Compilation
                        .GetTypeByMetadataName("PCLMock.MockBehavior"));

            return context
                .SyntaxGenerator
                .ConstructorDeclaration(
                    name,
                    parameters: new[]
                    {
                        context
                            .SyntaxGenerator
                            .ParameterDeclaration(
                                "behavior",
                                mockBehaviorType,
                                initializer: context.SyntaxGenerator.MemberAccessExpression(mockBehaviorType, "Strict"))
                    },
                    accessibility: Accessibility.Public,
                    baseConstructorArguments: new[] { context.SyntaxGenerator.IdentifierName("behavior") },
                    statements: new[]
                    {
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .IdentifierName("ConfigureBehaviorGenerated")),
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .IdentifierName("ConfigureBehavior")),
                        context
                            .SyntaxGenerator
                            .IfStatement(
                                context
                                    .SyntaxGenerator
                                    .ValueEqualsExpression(
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName("behavior"),
                                        context
                                            .SyntaxGenerator
                                            .MemberAccessExpression(mockBehaviorType, "Loose")),
                                new[]
                                {
                                    context
                                        .SyntaxGenerator
                                        .InvocationExpression(
                                            context
                                                .SyntaxGenerator
                                                .IdentifierName("ConfigureLooseBehaviorGenerated")),
                                    context
                                        .SyntaxGenerator
                                        .InvocationExpression(
                                            context
                                                .SyntaxGenerator
                                                .IdentifierName("ConfigureLooseBehavior"))
                                })
                    });
        }

        private static SyntaxNode GetConfigureBehaviorGeneratedSyntax(
            Context context,
            INamedTypeSymbol interfaceSymbol,
            IImmutableList<IPlugin> plugins,
            MockBehavior behavior)
        {
            var statements = GetMembersRecursive(interfaceSymbol)
                .Select(symbol => GetConfigureBehaviorGeneratedForSymbol(context, interfaceSymbol, symbol, plugins, behavior))
                .Where(syntaxNode => syntaxNode != null)
                .ToImmutableList();

            return context
                .SyntaxGenerator
                .MethodDeclaration(
                    behavior == MockBehavior.Strict ? "ConfigureBehaviorGenerated" : "ConfigureLooseBehaviorGenerated",
                    accessibility: Accessibility.Private,
                    statements: statements);
        }

        private static SyntaxNode GetConfigureBehaviorGeneratedForSymbol(
            Context context,
            INamedTypeSymbol interfaceSymbol,
            ISymbol symbol,
            IImmutableList<IPlugin> plugins,
            MockBehavior behavior)
        {
            context
                .LogSink
                .Debug(logSource, "Considering symbol '{0}'.", symbol);

            var propertySymbol = symbol as IPropertySymbol;
            var methodSymbol = symbol as IMethodSymbol;

            INamedTypeSymbol returnType = null;

            if (propertySymbol != null)
            {
                if (propertySymbol.GetMethod == null)
                {
                    context
                        .LogSink
                        .Debug(logSource, "Ignoring symbol '{0}' because it is a write-only property.", symbol);
                    return null;
                }

                returnType = propertySymbol.GetMethod.ReturnType as INamedTypeSymbol;
            }
            else if (methodSymbol != null)
            {
                if (methodSymbol.AssociatedSymbol != null)
                {
                    context
                        .LogSink
                        .Debug(logSource, "Ignoring symbol '{0}' because it is a method with an associated symbol.", symbol);
                    return null;
                }

                if (methodSymbol.IsGenericMethod)
                {
                    context
                        .LogSink
                        .Debug(logSource, "Ignoring symbol '{0}' because it is a generic method.", symbol);
                    return null;
                }

                returnType = methodSymbol.ReturnType as INamedTypeSymbol;
            }
            else
            {
                context
                    .LogSink
                    .Debug(logSource, "Ignoring symbol '{0}' because it is neither a property nor a method.", symbol);
                return null;
            }

            if (returnType == null)
            {
                context
                    .LogSink
                    .Warn(logSource, "Ignoring symbol '{0}' because its return type could not be determined (it's probably a sgeneric).", symbol);
                return null;
            }

            var defaultValueSyntax = plugins
                .Select(plugin => plugin.GetDefaultValueSyntax(context, behavior, symbol, returnType))
                .Where(syntax => syntax != null)
                .FirstOrDefault();

            if (defaultValueSyntax == null)
            {
                return null;
            }

            var itType = context
                .SemanticModel
                .Compilation
                .GetTypeByMetadataName("PCLMock.It");

            if (itType == null)
            {
                context
                    .LogSink
                    .Error(logSource, "Failed to resolve It class.");
                return null;
            }

            var isAnyMethod = itType
                .GetMembers("IsAny")
                .Single();

            if (isAnyMethod == null)
            {
                context
                    .LogSink
                    .Error(logSource, "Failed to resolve IsAny method.");
                return null;
            }

            var lambdaParameterName = symbol.GetUniqueName();
            SyntaxNode lambdaExpression;

            if (propertySymbol != null)
            {
                if (!propertySymbol.IsIndexer)
                {
                    // GENERATED CODE:
                    //
                    //     this
                    //         .When(x => x.SymbolName)
                    lambdaExpression = context
                        .SyntaxGenerator
                        .MemberAccessExpression(
                            context
                                .SyntaxGenerator
                                .IdentifierName(lambdaParameterName),
                            propertySymbol.Name);
                }
                else
                {
                    // GENERATED CODE:
                    //
                    //     this
                    //         .When(x => x[It.IsAny<P1>(), It.IsAny<P2>() ...)
                    var whenArguments = propertySymbol
                        .Parameters
                        .Select(
                            parameter =>
                                context
                                    .SyntaxGenerator
                                    .InvocationExpression(
                                        context
                                            .SyntaxGenerator
                                            .MemberAccessExpression(
                                                context
                                                    .SyntaxGenerator
                                                    .TypeExpression(itType),
                                                context
                                                    .SyntaxGenerator
                                                    .GenericName(
                                                        "IsAny",
                                                        typeArguments: new[]
                                                        {
                                                            parameter.Type
                                                        }))));

                    lambdaExpression = context
                        .SyntaxGenerator
                        .ElementAccessExpression(
                            context
                                .SyntaxGenerator
                                .IdentifierName(lambdaParameterName),
                            arguments: whenArguments);
                }
            }
            else
            {
                // GENERATED CODE:
                //
                //     this
                //         .When(x => x.SymbolName(It.IsAny<P1>(), It.IsAny<P2>() ...)
                var whenArguments = methodSymbol
                    .Parameters
                    .Select(
                        parameter =>
                            context
                                .SyntaxGenerator
                                .InvocationExpression(
                                    context
                                        .SyntaxGenerator
                                        .MemberAccessExpression(
                                            context
                                                .SyntaxGenerator
                                                .TypeExpression(itType),
                                            context
                                                .SyntaxGenerator
                                                .GenericName(
                                                    "IsAny",
                                                    typeArguments: new[]
                                                    {
                                                        parameter.Type
                                                    }))));

                lambdaExpression = context
                    .SyntaxGenerator
                    .InvocationExpression(
                        context
                            .SyntaxGenerator
                            .MemberAccessExpression(
                                context
                                    .SyntaxGenerator
                                    .IdentifierName(lambdaParameterName),
                                methodSymbol.Name),
                        arguments: whenArguments);
            }

            var whenLambdaArgument = context
                .SyntaxGenerator
                .ValueReturningLambdaExpression(
                    lambdaParameterName,
                    lambdaExpression);

            var whenInvocation = context
                .SyntaxGenerator
                .InvocationExpression(
                    context
                        .SyntaxGenerator
                        .MemberAccessExpression(
                            context
                                .SyntaxGenerator
                                .ThisExpression(),
                            context
                                .SyntaxGenerator
                                .IdentifierName("When")),
                    whenLambdaArgument);

            var result = context
                .SyntaxGenerator
                .ExpressionStatement(
                    context
                        .SyntaxGenerator
                        .InvocationExpression(
                            context
                                .SyntaxGenerator
                                .MemberAccessExpression(
                                    whenInvocation,
                                    context
                                        .SyntaxGenerator
                                        .IdentifierName("Return")),
                            arguments: new[]
                            {
                                defaultValueSyntax
                            }));

            return result;
        }

        private static SyntaxNode GetConfigureBehaviorMethodSyntax(
            Context context)
        {
            // GENERATED CODE:
            //
            //     partial void ConfigureBehavior();
            return context
                .SyntaxGenerator
                .MethodDeclaration(
                    "ConfigureBehavior",
                    accessibility: context.Language == Language.VisualBasic ? Accessibility.Private : Accessibility.NotApplicable,
                    modifiers: DeclarationModifiers.Partial);
        }

        private static SyntaxNode GetConfigureLooseBehaviorMethodSyntax(
            Context context)
        {
            // GENERATED CODE:
            //
            //     partial void ConfigureLooseBehavior();
            return context
                .SyntaxGenerator
                .MethodDeclaration(
                    "ConfigureLooseBehavior",
                    accessibility: context.Language == Language.VisualBasic ? Accessibility.Private : Accessibility.NotApplicable,
                    modifiers: DeclarationModifiers.Partial);
        }

        private static IEnumerable<SyntaxNode> GetMemberDeclarations(
            Context context,
            string name,
            INamedTypeSymbol interfaceSymbol,
            IImmutableList<IPlugin> plugins)
        {
            return
                new SyntaxNode[]
                {
                    GetConstructorDeclarationSyntax(context, name),
                    GetConfigureBehaviorGeneratedSyntax(context, interfaceSymbol, plugins, MockBehavior.Strict),
                    GetConfigureBehaviorGeneratedSyntax(context, interfaceSymbol, plugins, MockBehavior.Loose),
                    GetConfigureBehaviorMethodSyntax(context),
                    GetConfigureLooseBehaviorMethodSyntax(context)
                }
                .Concat(
                    GetMembersRecursive(interfaceSymbol)
                        .Select(x => GetMemberDeclarationSyntax(context, x))
                        .Where(x => x != null)
                        .GroupBy(x => x, SyntaxNodeEqualityComparer.Instance)
                        .Where(group => group.Count() == 1)
                        .SelectMany(group => group)
                        .Select(x => context.SyntaxGenerator.AsPublicInterfaceImplementation(x, context.SyntaxGenerator.TypeExpression(interfaceSymbol))));
        }

        private static IEnumerable<ISymbol> GetMembersRecursive(INamedTypeSymbol interfaceSymbol)
        {
            foreach (var member in interfaceSymbol.GetMembers())
            {
                yield return member;
            }

            foreach (var implementedInterface in interfaceSymbol.Interfaces)
            {
                foreach (var member in GetMembersRecursive(implementedInterface))
                {
                    yield return member;
                }
            }
        }

        private static SyntaxNode GetMemberDeclarationSyntax(
            Context context,
            ISymbol symbol)
        {
            var propertySymbol = symbol as IPropertySymbol;

            if (propertySymbol != null)
            {
                return GetPropertyDeclarationSyntax(context, propertySymbol);
            }

            var methodSymbol = symbol as IMethodSymbol;

            if (methodSymbol != null)
            {
                return GetMethodDeclarationSyntax(context, methodSymbol);
            }

            // unsupported symbol type, but we don't error - the user can supplement our code as necessary because it's a partial class
            return null;
        }

        private static SyntaxNode GetPropertyDeclarationSyntax(
            Context context,
            IPropertySymbol propertySymbol)
        {
            var getAccessorStatements = GetPropertyGetAccessorsSyntax(context, propertySymbol).ToList();
            var setAccessorStatements = GetPropertySetAccessorsSyntax(context, propertySymbol).ToList();
            var declarationModifiers = DeclarationModifiers.None;

            if (getAccessorStatements.Count == 0)
            {
                declarationModifiers = declarationModifiers.WithIsWriteOnly(true);

                // set-only properties are not currently supported
                return null;
            }

            if (setAccessorStatements.Count == 0)
            {
                declarationModifiers = declarationModifiers.WithIsReadOnly(true);
            }

            if (!propertySymbol.IsIndexer)
            {
                return context
                    .SyntaxGenerator
                    .PropertyDeclaration(
                        propertySymbol.Name,
                        context
                            .SyntaxGenerator
                            .TypeExpression(propertySymbol.Type),
                        accessibility: Accessibility.Public,
                        modifiers: declarationModifiers,
                        getAccessorStatements: getAccessorStatements,
                        setAccessorStatements: setAccessorStatements);
            }
            else
            {
                var parameters = propertySymbol
                    .Parameters
                    .Select(x => context.SyntaxGenerator.ParameterDeclaration(x.Name, context.SyntaxGenerator.TypeExpression(x.Type)))
                    .ToList();

                return context
                    .SyntaxGenerator
                    .IndexerDeclaration(
                        parameters,
                        context.SyntaxGenerator.TypeExpression(propertySymbol.Type),
                        accessibility: Accessibility.Public,
                        modifiers: declarationModifiers,
                        getAccessorStatements: getAccessorStatements,
                        setAccessorStatements: setAccessorStatements);
            }
        }

        private static IEnumerable<SyntaxNode> GetPropertyGetAccessorsSyntax(
            Context context,
            IPropertySymbol propertySymbol)
        {
            if (propertySymbol.GetMethod == null)
            {
                yield break;
            }

            var lambdaParameterName = propertySymbol.GetUniqueName();

            if (!propertySymbol.IsIndexer)
            {
                // GENERATED CODE:
                //
                //     return this.Apply(x => x.PropertyName);
                yield return context
                    .SyntaxGenerator
                    .ReturnStatement(
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .MemberAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .ThisExpression(),
                                        "Apply"),
                                context
                                    .SyntaxGenerator
                                    .ValueReturningLambdaExpression(
                                        lambdaParameterName,
                                        context
                                            .SyntaxGenerator
                                            .MemberAccessExpression(
                                                context
                                                    .SyntaxGenerator
                                                    .IdentifierName(lambdaParameterName),
                                                context
                                                    .SyntaxGenerator
                                                    .IdentifierName(propertySymbol.Name)))));
            }
            else
            {
                // GENERATED CODE:
                //
                //     return this.Apply(x => x[first, second]);
                var arguments = propertySymbol
                    .Parameters
                    .Select(x => context.SyntaxGenerator.Argument(context.SyntaxGenerator.IdentifierName(x.Name)))
                    .ToList();

                yield return context
                    .SyntaxGenerator
                    .ReturnStatement(
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .MemberAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .ThisExpression(),
                                        "Apply"),
                                context
                                    .SyntaxGenerator
                                    .ValueReturningLambdaExpression(
                                        lambdaParameterName,
                                        context
                                            .SyntaxGenerator
                                            .ElementAccessExpression(
                                                context
                                                    .SyntaxGenerator
                                                    .IdentifierName(lambdaParameterName),
                                                arguments))));
            }
        }

        private static IEnumerable<SyntaxNode> GetPropertySetAccessorsSyntax(
            Context context,
            IPropertySymbol propertySymbol)
        {
            if (propertySymbol.SetMethod == null)
            {
                yield break;
            }

            var lambdaParameterName = propertySymbol.GetUniqueName();

            if (!propertySymbol.IsIndexer)
            {
                // GENERATED CODE:
                //
                //     this.ApplyPropertySet(x => x.PropertyName, value);
                yield return context
                    .SyntaxGenerator
                    .InvocationExpression(
                        context
                            .SyntaxGenerator
                            .MemberAccessExpression(
                                context
                                    .SyntaxGenerator
                                    .ThisExpression(),
                                "ApplyPropertySet"),
                        context
                            .SyntaxGenerator
                            .ValueReturningLambdaExpression(
                                lambdaParameterName,
                                context
                                    .SyntaxGenerator
                                    .MemberAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName(lambdaParameterName),
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName(propertySymbol.Name))),
                        context
                            .SyntaxGenerator
                            .IdentifierName("value"));
            }
            else
            {
                // GENERATED CODE:
                //
                //     this.ApplyPropertySet(x => x[first, second], value);
                var arguments = propertySymbol
                    .Parameters
                    .Select(x => context.SyntaxGenerator.Argument(context.SyntaxGenerator.IdentifierName(x.Name)))
                    .ToList();

                yield return context
                    .SyntaxGenerator
                    .InvocationExpression(
                        context
                            .SyntaxGenerator
                            .MemberAccessExpression(
                                context
                                    .SyntaxGenerator
                                    .ThisExpression(),
                                "ApplyPropertySet"),
                        context
                            .SyntaxGenerator
                            .ValueReturningLambdaExpression(
                                lambdaParameterName,
                                context
                                    .SyntaxGenerator
                                    .ElementAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName(lambdaParameterName),
                                        arguments)),
                        context
                            .SyntaxGenerator
                            .IdentifierName("value"));
            }
        }

        private static SyntaxNode GetMethodDeclarationSyntax(
            Context context,
            IMethodSymbol methodSymbol)
        {
            if (methodSymbol.MethodKind != MethodKind.Ordinary)
            {
                return null;
            }

            var methodDeclaration = context
                .SyntaxGenerator
                .MethodDeclaration(methodSymbol);
            methodDeclaration = context
                .SyntaxGenerator
                .WithModifiers(
                    methodDeclaration,
                    context
                        .SyntaxGenerator
                        .GetModifiers(methodDeclaration)
                        .WithIsAbstract(false));
            methodDeclaration = context
                .SyntaxGenerator
                .WithStatements(
                    methodDeclaration,
                    GetMethodStatementsSyntax(context, methodSymbol));

            var csharpMethodDeclaration = methodDeclaration as MethodDeclarationSyntax;

            if (csharpMethodDeclaration != null)
            {
                // remove trailing semi-colon from the declaration
                methodDeclaration = csharpMethodDeclaration.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }

            return methodDeclaration;
        }

        private static IEnumerable<SyntaxNode> GetMethodStatementsSyntax(
            Context context,
            IMethodSymbol methodSymbol)
        {
            // GENERATED CODE (for every ref or out parameter):
            //
            //     string someOutParameter;
            //     var someRefParameter = default(int);
            for (var i = 0; i < methodSymbol.Parameters.Length; ++i)
            {
                var parameter = methodSymbol.Parameters[i];

                if (parameter.RefKind == RefKind.Out)
                {
                    yield return context
                        .SyntaxGenerator
                        .LocalDeclarationStatement(
                            context
                                .SyntaxGenerator
                                .TypeExpression(parameter.Type),
                            methodSymbol.GetNameForParameter(parameter));
                }
                else if (parameter.RefKind == RefKind.Ref)
                {
                    yield return context
                        .SyntaxGenerator
                        .LocalDeclarationStatement(
                            methodSymbol.GetNameForParameter(parameter),
                            initializer: context.SyntaxGenerator.DefaultExpression(context.SyntaxGenerator.TypeExpression(parameter.Type)));
                }
            }

            var arguments = methodSymbol
                .Parameters
                .Select(x =>
                    context
                        .SyntaxGenerator
                        .Argument(
                            x.RefKind,
                            context
                                .SyntaxGenerator
                                .IdentifierName(methodSymbol.GetNameForParameter(x))))
                .ToList();

            var typeArguments = methodSymbol
                .TypeArguments
                .Select(x => context.SyntaxGenerator.TypeExpression(x))
                .ToList();

            var lambdaParameterName = methodSymbol.GetUniqueName();

            var lambdaInvocation = context
                .SyntaxGenerator
                .MemberAccessExpression(
                    context
                        .SyntaxGenerator
                        .IdentifierName(lambdaParameterName),
                    methodSymbol.Name);

            if (typeArguments.Count > 0)
            {
                lambdaInvocation = context
                    .SyntaxGenerator
                    .WithTypeArguments(
                        lambdaInvocation,
                        typeArguments);
            }

            // GENERATED CODE (for every ref or out parameter):
            //
            //     someOutParameter = this.GetOutParameterValue<string>(x => x.TheMethod(out someOutParameter), parameterIndex: 0);
            //     someRefParameter = this.GetRefParameterValue<int>(x => x.TheMethod(ref someRefParameter), parameterIndex: 0);
            for (var i = 0; i < methodSymbol.Parameters.Length; ++i)
            {
                var parameter = methodSymbol.Parameters[i];

                if (parameter.RefKind == RefKind.Out || parameter.RefKind == RefKind.Ref)
                {
                    var nameOfMethodToCall = parameter.RefKind == RefKind.Out ? "GetOutParameterValue" : "GetRefParameterValue";

                    yield return context
                        .SyntaxGenerator
                        .AssignmentStatement(
                            context
                                .SyntaxGenerator
                                .IdentifierName(parameter.Name),
                            context
                                .SyntaxGenerator
                                .InvocationExpression(
                                    context
                                        .SyntaxGenerator
                                        .MemberAccessExpression(
                                            context
                                                .SyntaxGenerator
                                                .ThisExpression(),
                                            context
                                                .SyntaxGenerator
                                                .GenericName(
                                                    nameOfMethodToCall,
                                                    typeArguments: context.SyntaxGenerator.TypeExpression(parameter.Type))),
                                                    arguments: new[]
                                                    {
                                                        context
                                                            .SyntaxGenerator
                                                            .ValueReturningLambdaExpression(
                                                                lambdaParameterName,
                                                                context
                                                                    .SyntaxGenerator
                                                                    .InvocationExpression(
                                                                        lambdaInvocation,
                                                                        arguments: arguments)),
                                                                context
                                                                    .SyntaxGenerator
                                                                    .LiteralExpression(i)
                                                    }));
                }
            }

            // GENERATED CODE:
            //
            //     [return] this.Apply(x => x.SomeMethod(param1, param2));
            var applyInvocation = context
                .SyntaxGenerator
                .InvocationExpression(
                    context
                        .SyntaxGenerator
                        .MemberAccessExpression(
                            context
                                .SyntaxGenerator
                                .ThisExpression(),
                            "Apply"),
                    context
                        .SyntaxGenerator
                        .ValueReturningLambdaExpression(
                            lambdaParameterName,
                            context
                                .SyntaxGenerator
                                .InvocationExpression(
                                    lambdaInvocation,
                                    arguments: arguments)));

            if (!methodSymbol.ReturnsVoid)
            {
                applyInvocation = context
                    .SyntaxGenerator
                    .ReturnStatement(applyInvocation);
            }

            yield return applyInvocation;
        }

        private static IEnumerable<ISymbol> GetSymbolsRecursive(INamespaceSymbol namespaceSymbol)
        {
            // using a heap-based stack here instead of recursive call just to be sure we don't overflow the stack
            var stack = new Stack<INamespaceSymbol>();
            stack.Push(namespaceSymbol);

            while (stack.Count > 0)
            {
                var namespaceSymbolToProcess = stack.Pop();

                yield return namespaceSymbolToProcess;

                foreach (var namespaceMember in namespaceSymbolToProcess.GetMembers())
                {
                    var namespaceMemberAsNamespace = namespaceMember as INamespaceSymbol;

                    if (namespaceMemberAsNamespace != null)
                    {
                        stack.Push(namespaceMemberAsNamespace);
                    }
                    else
                    {
                        yield return namespaceMember;
                    }
                }
            }
        }

        private sealed class SyntaxNodeEqualityComparer : IEqualityComparer<SyntaxNode>
        {
            public static readonly SyntaxNodeEqualityComparer Instance = new SyntaxNodeEqualityComparer();

            private SyntaxNodeEqualityComparer()
            {
            }

            public bool Equals(SyntaxNode x, SyntaxNode y) =>
                x.IsEquivalentTo(y, topLevel: true);

            // We have to ensure like syntax nodes have the same hash code in order for Equals to even be called
            // Unfortunately, Roslyn does not implement GetHashCode, so we can't use that. We also don't want to
            // use ToString because then we may as well have just grouped by it and because it includes the
            // implementation, not just the declaration. To do this "properly", we'd have to write a recursive
            // hash code calculator, using similar logic to what IsEquivalentTo gives us.
            public int GetHashCode(SyntaxNode obj) =>
                0;
        }
    }
}