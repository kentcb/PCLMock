namespace PCLMock.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using System.Reflection;
    using Logging;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Editing;
    using PCLMock.CodeGeneration.Plugins;

    public static class Generator
    {
        private const string headerComment =
@"-----------------------------------------------------------------------
<autogenerated>
   This code was generated from a template.

   Changes to this file may cause incorrect behaviour and will be lost
   if the code is regenerated.
</autogenerated>
------------------------------------------------------------------------";

        public static IImmutableList<SyntaxNode> GenerateMocks(
            ILogSink logSink,
            Language language,
            IImmutableList<Compilation> compilations,
            IImmutableList<IPlugin> plugins,
            Func<INamedTypeSymbol, bool> interfacePredicate,
            Func<INamedTypeSymbol, string> mockNamespaceSelector,
            Func<INamedTypeSymbol, string> mockNameSelector)
        {
            logSink = logSink.WithSource(typeof(Generator));
            logSink.Debug("Creating adhoc workspace.");

            var workspace = new AdhocWorkspace();
            var syntaxGenerator = SyntaxGenerator.GetGenerator(workspace, language.ToSyntaxGeneratorLanguageName());

            // The default plugin is always included last.
            plugins = plugins.Add(Default.Instance);

            return compilations
                // Make sure the compilation has a reference to PCLMock, even if the project hosting the code doesn't. That allows us
                // to generate the code even if it doesn't end up building due to the missing PCLMock reference.
                .Select(compilation => compilation.AddReferences(MetadataReference.CreateFromFile(typeof(MockBase<>).GetTypeInfo().Assembly.Location)))
                // Then allow all plugins to tweak the compilation.
                .Select(compilation => plugins.Aggregate(compilation, (acc, next) => next.InitializeCompilation(logSink, acc)))
                .SelectMany(compilation => GetNamedTypeSymbolsInSource(compilation).Select(namedTypeSymbol => (compilation, namedTypeSymbol)))
                .Where(compilationAndSymbol => compilationAndSymbol.namedTypeSymbol.TypeKind == TypeKind.Interface && !compilationAndSymbol.namedTypeSymbol.IsImplicitlyDeclared)
                .Where(compilationAndSymbol => interfacePredicate == null || interfacePredicate(compilationAndSymbol.namedTypeSymbol))
                .Select(
                    compilationAndSymbol =>
                    {
                        var syntaxTree = compilationAndSymbol
                            .namedTypeSymbol
                            .DeclaringSyntaxReferences
                            .FirstOrDefault()
                            ?.SyntaxTree;

                        // This is critical for the case of having loaded multiple projects that reference each other. TODO: would be better if GetNamedTypeSymbolsInSource
                        // only obtained symbols in a given compilation, but that is presenting other issues.
                        if (!compilationAndSymbol.compilation.ContainsSyntaxTree(syntaxTree))
                        {
                            return (compilationAndSymbol.compilation, compilationAndSymbol.namedTypeSymbol, null);
                        }

                        var semanticModel = syntaxTree == null ? null : compilationAndSymbol.compilation.GetSemanticModel(syntaxTree);

                        if (semanticModel == null)
                        {
                            logSink.Warn(
                                "Cannot generate mock for included interface '{0}' because no semantic model could be obtained for it.",
                                compilationAndSymbol.namedTypeSymbol);
                        }

                        return (compilationAndSymbol.compilation, compilationAndSymbol.namedTypeSymbol, semanticModel);
                    })
                .Where(info => info.semanticModel != null)
                .Select(
                    info =>
                    {
                        var @namespace = mockNamespaceSelector(info.namedTypeSymbol);
                        var name = mockNameSelector(info.namedTypeSymbol);

                        logSink.Info(
                            "Generating mock for interface '{0}' with namespace '{1}', name '{2}'.",
                            info.namedTypeSymbol,
                            @namespace,
                            name);

                        var context = new Context(logSink, language, plugins, syntaxGenerator, info.semanticModel);
                        return GenerateMock(context, info.namedTypeSymbol, @namespace, name, plugins);
                    })
                .Select((syntaxNode, i) => i == 0 ? syntaxGenerator.WithLeadingComments(syntaxNode, headerComment, language) : syntaxNode)
                .ToImmutableList();
        }

        private static SyntaxNode GenerateMock(
            Context context,
            INamedTypeSymbol interfaceSymbol,
            string mockNamespace,
            string mockName,
            IImmutableList<IPlugin> plugins)
        {
            var namespaceSyntax = GetNamespaceDeclarationSyntax(context, mockNamespace);
            var classSyntax = GetClassDeclarationSyntax(context, mockName, interfaceSymbol);

            classSyntax = context
                .SyntaxGenerator
                .AddAttributes(classSyntax, GetClassAttributesSyntax(context));
            classSyntax = context
                .SyntaxGenerator
                .AddMembers(classSyntax, GetMemberDeclarations(context, mockName, interfaceSymbol, plugins));
            namespaceSyntax = context
                .SyntaxGenerator
                .AddMembers(namespaceSyntax, classSyntax);

            return context
                .SyntaxGenerator
                .CompilationUnit(namespaceSyntax)
                .NormalizeWhitespace();
        }

        private static SyntaxNode GetNamespaceDeclarationSyntax(
            Context context,
            string @namespace)
        {
            return context
                .SyntaxGenerator
                .NamespaceDeclaration(@namespace);
        }

        private static SyntaxNode GetClassDeclarationSyntax(
            Context context,
            string name,
            INamedTypeSymbol interfaceSymbol)
        {
            var interfaceType = context
                .SyntaxGenerator
                .TypeExpression(interfaceSymbol);
            var mockBaseType = context
                .SemanticModel
                .Compilation
                .GetTypeByMetadataName("PCLMock.MockBase`1");

            if (mockBaseType == null)
            {
                throw new InvalidOperationException("Failed to find type in PCLMock assembly. Are you sure this project has a reference to PCLMock?");
            }

            var baseType = context
                .SyntaxGenerator
                .TypeExpression(
                    mockBaseType
                        .Construct(interfaceSymbol));

            var accessibility = interfaceSymbol.DeclaredAccessibility == Accessibility.NotApplicable
                ? Accessibility.Public
                : interfaceSymbol.DeclaredAccessibility;

            var classDeclaration = context
                .SyntaxGenerator
                .ClassDeclaration(
                    name,
                    accessibility: accessibility,
                    modifiers: DeclarationModifiers.Partial,
                    typeParameters: interfaceSymbol.TypeParameters.Select(x => x.Name),
                    baseType: baseType,
                    interfaceTypes: new[] { interfaceType });

            // TODO: tidy this up once this issue is rectified: https://github.com/dotnet/roslyn/issues/1658
            foreach (var typeParameter in interfaceSymbol.TypeParameters)
            {
                if (typeParameter.HasConstructorConstraint ||
                    typeParameter.HasReferenceTypeConstraint ||
                    typeParameter.HasValueTypeConstraint ||
                    typeParameter.ConstraintTypes.Length > 0)
                {
                    var kinds = (typeParameter.HasConstructorConstraint ? SpecialTypeConstraintKind.Constructor : SpecialTypeConstraintKind.None) |
                                (typeParameter.HasReferenceTypeConstraint ? SpecialTypeConstraintKind.ReferenceType : SpecialTypeConstraintKind.None) |
                                (typeParameter.HasValueTypeConstraint ? SpecialTypeConstraintKind.ValueType : SpecialTypeConstraintKind.None);

                    classDeclaration = context
                        .SyntaxGenerator
                        .WithTypeConstraint(
                            classDeclaration,
                            typeParameter.Name,
                            kinds: kinds,
                            types: typeParameter.ConstraintTypes.Select(t => context.SyntaxGenerator.TypeExpression(t)));
                }
            }

            return classDeclaration;
        }

        private static IEnumerable<SyntaxNode> GetClassAttributesSyntax(
            Context context)
        {
            // GENERATED CODE:
            //
            //     [System.CodeDom.Compiler.GeneratedCode("PCLMock", "[version]")]
            //     [System.Runtime.CompilerServices.CompilerGenerated)]
            yield return context
                .SyntaxGenerator
                .Attribute(
                    "System.CodeDom.Compiler.GeneratedCode",
                    context
                        .SyntaxGenerator
                        .LiteralExpression("PCLMock"),
                    context
                        .SyntaxGenerator
                        .LiteralExpression(typeof(MockBase<>).GetTypeInfo().Assembly.GetName().Version.ToString()));
            yield return context
                .SyntaxGenerator
                .Attribute(
                    "System.Runtime.CompilerServices.CompilerGenerated");
        }

        private static SyntaxNode GetConstructorDeclarationSyntax(
            Context context,
            string name)
        {
            // GENERATED CODE:
            //
            //     public Name(MockBehavior behavior = MockBehavior.Strict)
            //         : base(behavior)
            //     {
            //         ConfigureBehaviorGenerated();
            //         ConfigureBehavior();
            //
            //         if (behavior == MockBehavior.Loose)
            //         {
            //             ConfigureLooseBehavior();
            //         }
            //     }
            var mockBehaviorType = context
                .SyntaxGenerator
                .TypeExpression(
                    context
                        .SemanticModel
                        .Compilation
                        .GetTypeByMetadataName("PCLMock.MockBehavior"));

            return context
                .SyntaxGenerator
                .ConstructorDeclaration(
                    name,
                    parameters: new[]
                    {
                        context
                            .SyntaxGenerator
                            .ParameterDeclaration(
                                "behavior",
                                mockBehaviorType,
                                initializer: context.SyntaxGenerator.MemberAccessExpression(mockBehaviorType, "Strict"))
                    },
                    accessibility: Accessibility.Public,
                    baseConstructorArguments: new[] { context.SyntaxGenerator.IdentifierName("behavior") },
                    statements: new[]
                    {
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .IdentifierName("ConfigureBehaviorGenerated")),
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .IdentifierName("ConfigureBehavior")),
                        context
                            .SyntaxGenerator
                            .IfStatement(
                                context
                                    .SyntaxGenerator
                                    .ValueEqualsExpression(
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName("behavior"),
                                        context
                                            .SyntaxGenerator
                                            .MemberAccessExpression(mockBehaviorType, "Loose")),
                                new[]
                                {
                                    context
                                        .SyntaxGenerator
                                        .InvocationExpression(
                                            context
                                                .SyntaxGenerator
                                                .IdentifierName("ConfigureLooseBehavior"))
                                })
                    });
        }

        private static SyntaxNode GetConfigureBehaviorGeneratedForSymbol(
            Context context,
            INamedTypeSymbol interfaceSymbol,
            ISymbol symbol,
            IImmutableList<IPlugin> plugins,
            bool isExplicitRequired)
        {
            context
                .LogSink
                .Debug("Considering symbol '{0}' for generation of configure behavior.", symbol);

            var propertySymbol = symbol as IPropertySymbol;
            var methodSymbol = symbol as IMethodSymbol;

            ITypeSymbol returnType = null;

            if (propertySymbol != null)
            {
                if (propertySymbol.GetMethod == null)
                {
                    context
                        .LogSink
                        .Debug("Ignoring symbol '{0}' because it is a write-only property.", symbol);
                    return null;
                }

                returnType = propertySymbol.GetMethod.ReturnType as INamedTypeSymbol;
            }
            else if (methodSymbol != null)
            {
                if (methodSymbol.AssociatedSymbol != null)
                {
                    context
                        .LogSink
                        .Debug("Ignoring symbol '{0}' because it is a method with an associated symbol ('{1}').", symbol, methodSymbol.AssociatedSymbol);
                    return null;
                }

                if (methodSymbol.IsGenericMethod)
                {
                    context
                        .LogSink
                        .Debug("Ignoring symbol '{0}' because it is a generic method.", symbol);
                    return null;
                }

                returnType = methodSymbol.ReturnType as INamedTypeSymbol;
            }
            else
            {
                context
                    .LogSink
                    .Debug("Ignoring symbol '{0}' because it is neither a property nor a method.", symbol);
                return null;
            }

            if (returnType == null)
            {
                context
                    .LogSink
                    .Debug("Ignoring symbol '{0}' because its return type could not be determined (it's probably a generic).", symbol);
                return null;
            }

            var defaultValueSyntax = plugins
                .Select(plugin => plugin.GetDefaultValueSyntax(context, symbol, returnType))
                .Where(syntax => syntax != null)
                .FirstOrDefault();

            if (defaultValueSyntax == null)
            {
                return null;
            }

            var itType = context
                .SemanticModel
                .Compilation
                .GetTypeByMetadataName("PCLMock.It");

            if (itType == null)
            {
                context
                    .LogSink
                    .Error("Failed to resolve It class.");
                return null;
            }

            var isAnyMethod = itType
                .GetMembers("IsAny")
                .Single();

            if (isAnyMethod == null)
            {
                context
                    .LogSink
                    .Error("Failed to resolve IsAny method.");
                return null;
            }

            var lambdaParameterName = symbol.GetUniqueName();
            SyntaxNode lambdaExpression;

            if (propertySymbol != null)
            {
                if (!propertySymbol.IsIndexer)
                {
                    // GENERATED CODE:
                    //
                    //     this
                    //         .When(x => x.SymbolName)
                    lambdaExpression = context
                        .SyntaxGenerator
                        .MemberAccessExpression(
                            context
                                .SyntaxGenerator
                                .IdentifierName(lambdaParameterName),
                            propertySymbol.Name);
                }
                else
                {
                    // GENERATED CODE:
                    //
                    //     this
                    //         .When(x => x[It.IsAny<P1>(), It.IsAny<P2>() ...)
                    var whenArguments = propertySymbol
                        .Parameters
                        .Select(
                            parameter =>
                                context
                                    .SyntaxGenerator
                                    .InvocationExpression(
                                        context
                                            .SyntaxGenerator
                                            .MemberAccessExpression(
                                                context
                                                    .SyntaxGenerator
                                                    .TypeExpression(itType),
                                                context
                                                    .SyntaxGenerator
                                                    .GenericName(
                                                        "IsAny",
                                                        typeArguments: new[]
                                                        {
                                                            parameter.Type
                                                        }))));

                    lambdaExpression = context
                        .SyntaxGenerator
                        .ElementAccessExpression(
                            context
                                .SyntaxGenerator
                                .IdentifierName(lambdaParameterName),
                            arguments: whenArguments);
                }
            }
            else
            {
                // GENERATED CODE:
                //
                //     this
                //         .When(x => x.SymbolName(It.IsAny<P1>(), It.IsAny<P2>() ...)
                //
                // OR (FOR EXPLICIT):
                //
                //     this
                //         .When(x => ((TypeContainingSymbol)x).SymbolName(It.IsAny<P1>(), It.IsAny<P2>() ...)
                var whenArguments = methodSymbol
                    .Parameters
                    .Select(
                        parameter =>
                            context
                                .SyntaxGenerator
                                .InvocationExpression(
                                    context
                                        .SyntaxGenerator
                                        .MemberAccessExpression(
                                            context
                                                .SyntaxGenerator
                                                .TypeExpression(itType),
                                            context
                                                .SyntaxGenerator
                                                .GenericName(
                                                    "IsAny",
                                                    typeArguments: new[]
                                                    {
                                                        parameter.Type
                                                    }))));

                var memberToAccess = context
                    .SyntaxGenerator
                    .IdentifierName(lambdaParameterName);

                if (isExplicitRequired)
                {
                    memberToAccess = context
                        .SyntaxGenerator
                        .CastExpression(
                            context
                                .SyntaxGenerator
                                .TypeExpression(methodSymbol.ContainingType),
                            memberToAccess);
                }

                lambdaExpression = context
                    .SyntaxGenerator
                    .InvocationExpression(
                        context
                            .SyntaxGenerator
                            .MemberAccessExpression(
                                memberToAccess,
                                methodSymbol.Name),
                        arguments: whenArguments);
            }

            var whenLambdaArgument = context
                .SyntaxGenerator
                .ValueReturningLambdaExpression(
                    lambdaParameterName,
                    lambdaExpression);

            var whenInvocation = context
                .SyntaxGenerator
                .InvocationExpression(
                    context
                        .SyntaxGenerator
                        .MemberAccessExpression(
                            context
                                .SyntaxGenerator
                                .ThisExpression(),
                            context
                                .SyntaxGenerator
                                .IdentifierName("When")),
                    whenLambdaArgument);

            var result = context
                .SyntaxGenerator
                .ExpressionStatement(
                    context
                        .SyntaxGenerator
                        .InvocationExpression(
                            context
                                .SyntaxGenerator
                                .MemberAccessExpression(
                                    whenInvocation,
                                    context
                                        .SyntaxGenerator
                                        .IdentifierName("Return")),
                            arguments: new[]
                            {
                                defaultValueSyntax
                            }));

            return result;
        }

        private static SyntaxNode GetConfigureBehaviorMethodSyntax(
            Context context)
        {
            // GENERATED CODE:
            //
            //     partial void ConfigureBehavior();
            return context
                .SyntaxGenerator
                .MethodDeclaration(
                    "ConfigureBehavior",
                    accessibility: context.Language == Language.VisualBasic ? Accessibility.Private : Accessibility.NotApplicable,
                    modifiers: DeclarationModifiers.Partial);
        }

        private static SyntaxNode GetConfigureLooseBehaviorMethodSyntax(
            Context context)
        {
            // GENERATED CODE:
            //
            //     partial void ConfigureLooseBehavior();
            return context
                .SyntaxGenerator
                .MethodDeclaration(
                    "ConfigureLooseBehavior",
                    accessibility: context.Language == Language.VisualBasic ? Accessibility.Private : Accessibility.NotApplicable,
                    modifiers: DeclarationModifiers.Partial);
        }

        private static IEnumerable<SyntaxNode> GetMemberDeclarations(
            Context context,
            string name,
            INamedTypeSymbol interfaceSymbol,
            IImmutableList<IPlugin> plugins)
        {
            var members = GetDistinctMembersRecursive(interfaceSymbol, context.LogSink)
                .ToList();

            // All members with a flag indicating whether explicit implementation is required.
            var membersWithExplicitFlag = members
                .Select((member, index) =>
                {
                    // Explicit implementation is required if any prior member has the same name and parameters as this one.
                    var isExplicitRequired = members
                        .Take(index)
                        .Any(symbol => ExplicitImplementationRequiredComparer.Instance.Equals(symbol, member));
                    return (member, isExplicitRequired);
                })
                .ToList();

            var interfaceTypeExpression = context.SyntaxGenerator.TypeExpression(interfaceSymbol);

            var configureBehaviorStatements = membersWithExplicitFlag
                .Select(x => GetConfigureBehaviorGeneratedForSymbol(context, interfaceSymbol, x.member, plugins, x.isExplicitRequired))
                .Where(syntaxNode => syntaxNode != null)
                .ToImmutableList();
            var configureBehaviorMethod = context
                .SyntaxGenerator
                .MethodDeclaration(
                    "ConfigureBehaviorGenerated",
                    accessibility: Accessibility.Private,
                    statements: configureBehaviorStatements);

            var memberDeclarations = membersWithExplicitFlag
                        .Select(
                            x =>
                            {
                                var memberDeclaration = GetMemberDeclarationSyntax(context, x.member, x.isExplicitRequired);

                                if (memberDeclaration == null)
                                {
                                    return null;
                                }

                                var typeContainingMember = context
                                    .SyntaxGenerator
                                    .TypeExpression(x.member.ContainingType);

                                if (x.isExplicitRequired)
                                {
                                    return context
                                        .SyntaxGenerator
                                        .AsPrivateInterfaceImplementation(memberDeclaration, typeContainingMember);
                                }
                                else
                                {
                                    return context
                                        .SyntaxGenerator
                                        .AsPublicInterfaceImplementation(memberDeclaration, typeContainingMember);
                                }
                            })
                        .Where(x => x != null);

            return
                new SyntaxNode[]
                {
                    GetConstructorDeclarationSyntax(context, name),
                    configureBehaviorMethod,
                    GetConfigureBehaviorMethodSyntax(context),
                    GetConfigureLooseBehaviorMethodSyntax(context)
                }
                .Concat(memberDeclarations);
        }

        private static IEnumerable<ISymbol> GetMembersRecursive(INamedTypeSymbol interfaceSymbol, ILogSink logSink)
        {
            foreach (var member in interfaceSymbol.GetMembers())
            {
                yield return member;
            }

            foreach (var implementedInterface in interfaceSymbol.Interfaces)
            {
                foreach (var member in GetMembersRecursive(implementedInterface, logSink))
                {
                    yield return member;
                }
            }
        }

        private static IEnumerable<ISymbol> GetDistinctMembersRecursive(INamedTypeSymbol interfaceSymbol, ILogSink logSink) =>
            GetMembersRecursive(interfaceSymbol, logSink)
                .Distinct(SymbolEqualityComparer.Default);

        private static SyntaxNode GetMemberDeclarationSyntax(
            Context context,
            ISymbol symbol,
            bool isExplicitRequired)
        {
            var propertySymbol = symbol as IPropertySymbol;

            if (propertySymbol != null)
            {
                return GetPropertyDeclarationSyntax(context, propertySymbol);
            }

            var methodSymbol = symbol as IMethodSymbol;

            if (methodSymbol != null)
            {
                return GetMethodDeclarationSyntax(context, methodSymbol, isExplicitRequired);
            }

            // unsupported symbol type, but we don't error - the user can supplement our code as necessary because it's a partial class
            return null;
        }

        private static SyntaxNode GetPropertyDeclarationSyntax(
            Context context,
            IPropertySymbol propertySymbol)
        {
            var getAccessorStatements = GetPropertyGetAccessorsSyntax(context, propertySymbol).ToList();
            var setAccessorStatements = GetPropertySetAccessorsSyntax(context, propertySymbol).ToList();
            var declarationModifiers = DeclarationModifiers.None;

            if (getAccessorStatements.Count == 0)
            {
                declarationModifiers = declarationModifiers.WithIsWriteOnly(true);

                // set-only properties are not currently supported
                return null;
            }

            if (setAccessorStatements.Count == 0)
            {
                declarationModifiers = declarationModifiers.WithIsReadOnly(true);
            }

            if (!propertySymbol.IsIndexer)
            {
                return context
                    .SyntaxGenerator
                    .PropertyDeclaration(
                        propertySymbol.Name,
                        context
                            .SyntaxGenerator
                            .TypeExpression(propertySymbol.Type),
                        accessibility: Accessibility.Public,
                        modifiers: declarationModifiers,
                        getAccessorStatements: getAccessorStatements,
                        setAccessorStatements: setAccessorStatements);
            }
            else
            {
                var parameters = propertySymbol
                    .Parameters
                    .Select(x => context.SyntaxGenerator.ParameterDeclaration(x.Name, context.SyntaxGenerator.TypeExpression(x.Type)))
                    .ToList();

                return context
                    .SyntaxGenerator
                    .IndexerDeclaration(
                        parameters,
                        context.SyntaxGenerator.TypeExpression(propertySymbol.Type),
                        accessibility: Accessibility.Public,
                        modifiers: declarationModifiers,
                        getAccessorStatements: getAccessorStatements,
                        setAccessorStatements: setAccessorStatements);
            }
        }

        private static IEnumerable<SyntaxNode> GetPropertyGetAccessorsSyntax(
            Context context,
            IPropertySymbol propertySymbol)
        {
            if (propertySymbol.GetMethod == null)
            {
                yield break;
            }

            var lambdaParameterName = propertySymbol.GetUniqueName();

            if (!propertySymbol.IsIndexer)
            {
                // GENERATED CODE:
                //
                //     return this.Apply(x => x.PropertyName);
                yield return context
                    .SyntaxGenerator
                    .ReturnStatement(
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .MemberAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .ThisExpression(),
                                        "Apply"),
                                context
                                    .SyntaxGenerator
                                    .ValueReturningLambdaExpression(
                                        lambdaParameterName,
                                        context
                                            .SyntaxGenerator
                                            .MemberAccessExpression(
                                                context
                                                    .SyntaxGenerator
                                                    .IdentifierName(lambdaParameterName),
                                                context
                                                    .SyntaxGenerator
                                                    .IdentifierName(propertySymbol.Name)))));
            }
            else
            {
                // GENERATED CODE:
                //
                //     return this.Apply(x => x[first, second]);
                var arguments = propertySymbol
                    .Parameters
                    .Select(x => context.SyntaxGenerator.Argument(context.SyntaxGenerator.IdentifierName(x.Name)))
                    .ToList();

                yield return context
                    .SyntaxGenerator
                    .ReturnStatement(
                        context
                            .SyntaxGenerator
                            .InvocationExpression(
                                context
                                    .SyntaxGenerator
                                    .MemberAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .ThisExpression(),
                                        "Apply"),
                                context
                                    .SyntaxGenerator
                                    .ValueReturningLambdaExpression(
                                        lambdaParameterName,
                                        context
                                            .SyntaxGenerator
                                            .ElementAccessExpression(
                                                context
                                                    .SyntaxGenerator
                                                    .IdentifierName(lambdaParameterName),
                                                arguments))));
            }
        }

        private static IEnumerable<SyntaxNode> GetPropertySetAccessorsSyntax(
            Context context,
            IPropertySymbol propertySymbol)
        {
            if (propertySymbol.SetMethod == null)
            {
                yield break;
            }

            var lambdaParameterName = propertySymbol.GetUniqueName();

            if (!propertySymbol.IsIndexer)
            {
                // GENERATED CODE:
                //
                //     this.ApplyPropertySet(x => x.PropertyName, value);
                yield return context
                    .SyntaxGenerator
                    .InvocationExpression(
                        context
                            .SyntaxGenerator
                            .MemberAccessExpression(
                                context
                                    .SyntaxGenerator
                                    .ThisExpression(),
                                "ApplyPropertySet"),
                        context
                            .SyntaxGenerator
                            .ValueReturningLambdaExpression(
                                lambdaParameterName,
                                context
                                    .SyntaxGenerator
                                    .MemberAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName(lambdaParameterName),
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName(propertySymbol.Name))),
                        context
                            .SyntaxGenerator
                            .IdentifierName("value"));
            }
            else
            {
                // GENERATED CODE:
                //
                //     this.ApplyPropertySet(x => x[first, second], value);
                var arguments = propertySymbol
                    .Parameters
                    .Select(x => context.SyntaxGenerator.Argument(context.SyntaxGenerator.IdentifierName(x.Name)))
                    .ToList();

                yield return context
                    .SyntaxGenerator
                    .InvocationExpression(
                        context
                            .SyntaxGenerator
                            .MemberAccessExpression(
                                context
                                    .SyntaxGenerator
                                    .ThisExpression(),
                                "ApplyPropertySet"),
                        context
                            .SyntaxGenerator
                            .ValueReturningLambdaExpression(
                                lambdaParameterName,
                                context
                                    .SyntaxGenerator
                                    .ElementAccessExpression(
                                        context
                                            .SyntaxGenerator
                                            .IdentifierName(lambdaParameterName),
                                        arguments)),
                        context
                            .SyntaxGenerator
                            .IdentifierName("value"));
            }
        }

        private static SyntaxNode GetMethodDeclarationSyntax(
            Context context,
            IMethodSymbol methodSymbol,
            bool isExplicitRequired)
        {
            if (methodSymbol.MethodKind != MethodKind.Ordinary)
            {
                return null;
            }

            var methodDeclaration = context
                .SyntaxGenerator
                .MethodDeclaration(methodSymbol);
            methodDeclaration = context
                .SyntaxGenerator
                .WithModifiers(
                    methodDeclaration,
                    context
                        .SyntaxGenerator
                        .GetModifiers(methodDeclaration)
                        .WithIsAbstract(false));
            methodDeclaration = context
                .SyntaxGenerator
                .WithStatements(
                    methodDeclaration,
                    GetMethodStatementsSyntax(context, methodSymbol, isExplicitRequired));

            var csharpMethodDeclaration = methodDeclaration as MethodDeclarationSyntax;

            if (csharpMethodDeclaration != null)
            {
                // remove trailing semi-colon from the declaration
                methodDeclaration = csharpMethodDeclaration.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }

            return methodDeclaration;
        }

        private static IEnumerable<SyntaxNode> GetMethodStatementsSyntax(
            Context context,
            IMethodSymbol methodSymbol,
            bool isExplicitRequired)
        {
            // GENERATED CODE (for every ref or out parameter):
            //
            //     string someOutParameter;
            //     var someRefParameter = default(int);
            for (var i = 0; i < methodSymbol.Parameters.Length; ++i)
            {
                var parameter = methodSymbol.Parameters[i];

                if (parameter.RefKind == RefKind.Out)
                {
                    yield return context
                        .SyntaxGenerator
                        .LocalDeclarationStatement(
                            context
                                .SyntaxGenerator
                                .TypeExpression(parameter.Type),
                            methodSymbol.GetNameForParameter(parameter));
                }
                else if (parameter.RefKind == RefKind.Ref)
                {
                    yield return context
                        .SyntaxGenerator
                        .LocalDeclarationStatement(
                            methodSymbol.GetNameForParameter(parameter),
                            initializer: context.SyntaxGenerator.DefaultExpression(context.SyntaxGenerator.TypeExpression(parameter.Type)));
                }
            }

            var arguments = methodSymbol
                .Parameters
                .Select(x =>
                    context
                        .SyntaxGenerator
                        .Argument(
                            x.RefKind,
                            context
                                .SyntaxGenerator
                                .IdentifierName(methodSymbol.GetNameForParameter(x))))
                .ToList();

            var typeArguments = methodSymbol
                .TypeArguments
                .Select(x => context.SyntaxGenerator.TypeExpression(x))
                .ToList();

            var lambdaParameterName = methodSymbol.GetUniqueName();
            var lambdaParameter = context
                .SyntaxGenerator
                .IdentifierName(lambdaParameterName);

            if (isExplicitRequired)
            {
                lambdaParameter = context
                    .SyntaxGenerator
                    .CastExpression(
                        context
                            .SyntaxGenerator
                            .TypeExpression(methodSymbol.ContainingType),
                        lambdaParameter);
            }

            var lambdaInvocation = context
                .SyntaxGenerator
                .MemberAccessExpression(
                    lambdaParameter,
                    methodSymbol.Name);

            if (typeArguments.Count > 0)
            {
                lambdaInvocation = context
                    .SyntaxGenerator
                    .WithTypeArguments(
                        lambdaInvocation,
                        typeArguments);
            }

            // GENERATED CODE (for every ref or out parameter):
            //
            //     someOutParameter = this.GetOutParameterValue<string>(x => x.TheMethod(out someOutParameter), parameterIndex: 0);
            //     someRefParameter = this.GetRefParameterValue<int>(x => x.TheMethod(ref someRefParameter), parameterIndex: 0);
            for (var i = 0; i < methodSymbol.Parameters.Length; ++i)
            {
                var parameter = methodSymbol.Parameters[i];

                if (parameter.RefKind == RefKind.Out || parameter.RefKind == RefKind.Ref)
                {
                    var nameOfMethodToCall = parameter.RefKind == RefKind.Out ? "GetOutParameterValue" : "GetRefParameterValue";

                    yield return context
                        .SyntaxGenerator
                        .AssignmentStatement(
                            context
                                .SyntaxGenerator
                                .IdentifierName(parameter.Name),
                            context
                                .SyntaxGenerator
                                .InvocationExpression(
                                    context
                                        .SyntaxGenerator
                                        .MemberAccessExpression(
                                            context
                                                .SyntaxGenerator
                                                .ThisExpression(),
                                            context
                                                .SyntaxGenerator
                                                .GenericName(
                                                    nameOfMethodToCall,
                                                    typeArguments: context.SyntaxGenerator.TypeExpression(parameter.Type))),
                                                    arguments: new[]
                                                    {
                                                        context
                                                            .SyntaxGenerator
                                                            .ValueReturningLambdaExpression(
                                                                lambdaParameterName,
                                                                context
                                                                    .SyntaxGenerator
                                                                    .InvocationExpression(
                                                                        lambdaInvocation,
                                                                        arguments: arguments)),
                                                                context
                                                                    .SyntaxGenerator
                                                                    .LiteralExpression(i)
                                                    }));
                }
            }

            // GENERATED CODE:
            //
            //     [return] this.Apply(x => x.SomeMethod(param1, param2));
            //
            // OR (FOR EXPLICIT):
            //
            //     [return] this.Apply(x => ((TypeContainingSomeMethod)x).SomeMethod(param1, param2));
            var applyInvocation = context
                .SyntaxGenerator
                .InvocationExpression(
                    context
                        .SyntaxGenerator
                        .MemberAccessExpression(
                            context
                                .SyntaxGenerator
                                .ThisExpression(),
                            "Apply"),
                    context
                        .SyntaxGenerator
                        .ValueReturningLambdaExpression(
                            lambdaParameterName,
                            context
                                .SyntaxGenerator
                                .InvocationExpression(
                                    lambdaInvocation,
                                    arguments: arguments)));

            if (!methodSymbol.ReturnsVoid)
            {
                applyInvocation = context
                    .SyntaxGenerator
                    .ReturnStatement(applyInvocation);
            }

            yield return applyInvocation;
        }

        private static IEnumerable<INamedTypeSymbol> GetNamedTypeSymbolsInSource(Compilation compilation)
        {
            var stack = new Stack<INamespaceSymbol>();
            stack.Push(compilation.GlobalNamespace);

            while (stack.Count > 0)
            {
                var @namespace = stack.Pop();

                foreach (var member in @namespace.GetMembers())
                {
                    if (member is INamespaceSymbol memberAsNamespace && memberAsNamespace.Locations.Any(x => x.IsInSource))
                    {
                        stack.Push(memberAsNamespace);
                    }
                    else if (member is INamedTypeSymbol memberAsNamedTypeSymbol)
                    {
                        yield return memberAsNamedTypeSymbol;
                    }
                }
            }
        }

        private sealed class SyntaxNodeEqualityComparer : IEqualityComparer<SyntaxNode>
        {
            public static readonly SyntaxNodeEqualityComparer Instance = new SyntaxNodeEqualityComparer();

            private SyntaxNodeEqualityComparer()
            {
            }

            public bool Equals(SyntaxNode x, SyntaxNode y) =>
                x.IsEquivalentTo(y, topLevel: true);

            // We have to ensure like syntax nodes have the same hash code in order for Equals to even be called
            // Unfortunately, Roslyn does not implement GetHashCode, so we can't use that. We also don't want to
            // use ToString because then we may as well have just grouped by it and because it includes the
            // implementation, not just the declaration. To do this "properly", we'd have to write a recursive
            // hash code calculator, using similar logic to what IsEquivalentTo gives us.
            public int GetHashCode(SyntaxNode obj) =>
                0;
        }

        // Considers symbols equal if they would required an explicit implementation to differentiate them in source
        // code. That is, they have the same name, parameters, and number of generic type parameters. Properties are
        // included in this decision, in which case they have no parameters and no generic type parameters.
        private sealed class ExplicitImplementationRequiredComparer : IEqualityComparer<ISymbol>
        {
            public static readonly ExplicitImplementationRequiredComparer Instance = new ExplicitImplementationRequiredComparer();

            private ExplicitImplementationRequiredComparer()
            {
            }

            public bool Equals(ISymbol x, ISymbol y)
            {
                if (x is null)
                {
                    return y is null;
                }
                else if (y is null)
                {
                    return false;
                }

                var xName = x.Name;
                var yName = y.Name;
                var xParameters = ImmutableArray<IParameterSymbol>.Empty;
                var yParameters = ImmutableArray<IParameterSymbol>.Empty;
                var xTypeParameters = ImmutableArray<ITypeParameterSymbol>.Empty;
                var yTypeParameters = ImmutableArray<ITypeParameterSymbol>.Empty;

                if (x is IMethodSymbol xMethod)
                {
                    xParameters = xMethod.Parameters;
                    xTypeParameters = xMethod.TypeParameters;
                }

                if (y is IMethodSymbol yMethod)
                {
                    yParameters = yMethod.Parameters;
                    yTypeParameters = yMethod.TypeParameters;
                }

                return
                    string.Equals(xName, yName, StringComparison.Ordinal) &&
                    xParameters.SequenceEqual(yParameters) &&
                    xTypeParameters.Length == yTypeParameters.Length;
            }

            public int GetHashCode(ISymbol symbol)
            {
                var name = symbol.Name;
                var parameters = ImmutableArray<IParameterSymbol>.Empty;
                var typeParameters = ImmutableArray<ITypeParameterSymbol>.Empty;

                if (symbol is IMethodSymbol methodSymbol)
                {
                    parameters = methodSymbol.Parameters;
                    typeParameters = methodSymbol.TypeParameters;
                }

                var hash = 17;
                hash = hash * 23 + name.GetHashCode();
                hash = hash * 23 + parameters.GetHashCode();
                hash = hash * 23 + typeParameters.GetHashCode();
                return hash;
            }
        }
    }
}